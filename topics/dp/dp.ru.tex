\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}


\definecolor{light-gray}{gray}{0.90}

\lstset{
    numbers=left,
    breaklines=true,
    tabsize=1,
    backgroundcolor=\color{light-gray},
    basicstyle=\ttfamily,
    keywordstyle=\bf\color{blue},
    language = Python,
}

\pagestyle{empty}

\begin{document}
  \section{Динамическое программирование}

    \subsection{Общие принципы}

      \subsubsection{Построение, оптимизация, комбинаторика}

      Формулировки задач динамического программирования чаще всего
      требует найти один из трёх результатов:

      \begin{enumerate}
        \item Построить некоторый объект с набором свойств. Например,
          найти в дереве путь, проходящий ровно по двум вершинам
          из выделенных.
        \item Оптимизировать некоторый параметр. Например, найти
          наибольшую возрастающую подпоследовательность. Здесь
          подпоследовательность~--- это объект, а её длина оптимизируется.
        \item Подсчитать количество способов построить некоторый
          объект. Например, найти количество чисел из цифр $0$ и $1$,
          делящихся на $3$.
      \end{enumerate}

      \subsubsection{Подзадачи}

      Задачи, решаемые методом динамического программирования,
      имеют основную общую особенность. Задачу в них можно сформулировать
      так, что решение можно свести к решению аналогичных задач меньшего
      размера~--- \emph{подзадач}.

      (Оптимальность для подзадачи)
      
      \subsubsection{Состояния, переходы, база}

      \subsubsection{ДП как перебор с запоминанием}

      \subsubsection{Выделение параметров, избыточность}

      (Задача о трёх кучках монет)

      (Добавить параметр, чтобы преобразовать оптимизацию в построение)

      \subsubsection{Восстановление ответа}

    \subsection{ДП на префиксах}

      \subsubsection{Кратчайший путь в ациклическом графе}

      \subsubsection{НВП}

      \subsubsection{НОП}
    
    \subsection{ДП по цифрам числа}

      \subsubsection{Количество чисел от 0 до n с суммой цифр k}
    
    \subsection{ДП на подотрезках}

      \subsubsection{Оптимальное перемножение матриц}

      \subsubsection{Наибольшая подпоследовательность-палиндром, подматрица-палиндром}
      \subsubsection{Казино}

    \subsection{ДП на поддеревьях}

      \subsubsection{Взвешенное паросочетание в дереве}

      \subsubsection{Выделение поддерева размера k}
      
      \textbf{Условие.} Дано дерево на $N$ вершинах и число $K$. 
      Найдите минимальное количество ребер, которое надо удалить из дерева, 
      чтобы одна из компонент оказалась размера ровно $K$. $\mathcal{O}(N^2)$
      
      Подвесим дерево за какую-нибудь вершину. Будем считать динамику 
      dp[$v$][$k$] ~--- минимальное количество ребер, при удалении которого
      поддерево $v$ распадется на такие компоненты, что содержащая $v$
      будет состоять из $k$ вершин.
      
      Примерный код:
      \begin{lstlisting}
          dp = [[INF] * (N + 1) for i in range(N)]
          size = [0] * N
          def dfs(v):
              size[v] = 1;
              dp[v][1] = len(g[v])
    
              for u in g[v]:
                  dfs(u)
                  for i in range(1, len(size[v]) + 1):
                      for j in range(1, len(size[u]) + 1):
                          dp[v][i + j] = min(dp[v][i + j], dp[u][j] + dp[v][i] - 1) 
                      size[v] += size[u]       
      \end{lstlisting}
      Подразумевается, что в g[$v$] хранится список смежности вершины
      $v$ без родителя

      Разберемся почему этот код работает.

      \textbf{Утверждение:} на $h$-м шаге внешнего цикла (7 строчка) 
      в dp[$v$][$k$] хранится ответ, если в компоненту с вершиной $v$
      разрешается брать лишь вершины из первых $h$ поддеревьев (нумерация с 1)
      \\
      
      Докажем его. При h = 0 утверждение очевидно. Пусть утверждение верно 
      после $h$ шагов, покажем, что оно верно и после $h + 1$ шага. В нашу 
      компоненту мы можем либо брать вершины из $h$-го поддерева, либо нет. 
      Если мы не берем, то, по предположению индрукции ответ dp[$v$][$k$]. 
      Если же мы берем, то посмотрим, сколько вершин мы взяли из предыдущих 
      поддеревьев (за это отвечает переменная $i$), а сколько - из 
      $(h + 1)$-го поддерева (за это отвечает $j$). ну и платим мы за это 
      соответственно dp[$u$][$j$] + dp[$v$][$i$] - 1 (-1 так как раньше мы 
      удаляли ребро между $v$ и ее $(h + 1)$-м ребенком, а теперь нет). 
      Поскольку $i$ и $j$ пробегают все возможные значения, то ответ 
      посчитается корректно. 
	  \\
	  
      \textbf{Утверждение:} dfs($v$) работает за 
      $\mathcal{O}(\operatorname{size}[v]^2)$ 

      Докажем по индукции по размеру поддерева. Пусть $\omega_h$ - 
      размер поддерева $h$-го ребенка $v$. Обозначим за $z$ количество 
      детей $v$ В цикле (7) мы вызовем dfs от всех детей (это 
      будет $\sum(c \cdot \omega_h^2)$ по предположению индукции. 
      Возьмем $c > 2$). На $h$-м шаге size[$v$] = 
       $(1 + \omega_1 + \cdots + \omega_{h - 1})$ соответственно на 
       $h$-м шаге цикл (9) выполнит суммарно 
       $\omega_{h + 1}~\cdot~(\sum\limits_{j \leqslant h}(\omega_h)~+~1)$ 
       операций. $$\sum\limits_{h = 0}^{z - 1}(\omega_{h + 1} \cdot 
       (\sum\limits_{j \leqslant h}(\omega_h) + 1)) = \sum\limits_{1 \leqslant i 
       \leqslant j \leqslant z}(w_i \cdot w_j) + \sum_{i \leqslant z}w_i $$
       $$\sum_{i \leqslant z} (c w_i^2) \sum\limits_{1 \leqslant i < j 
       \leqslant z}(w_i \cdot w_j) + \sum_{i \leqslant z}w_i \buildrel 
       c > 2 \over \leqslant c \cdot (\sum\limits_{i \leqslant z} 
       w_i) ^ 2$$

       Что и требовалось доказать.
       
       Таким образом, dfs($root$) работает за $\mathcal{O}(N^2)$. 
       Как же найти ответ на исходную задачу? Так как какая-то вершина в 
       полученной компоненту будет иметь минимальную глубину, то достаточно 
       запустить dfs($root$) и потом выбрать минимум из 
       $\operatorname{dp}[v][K] + 1$ по всем $v$ кроме $root$ и 
       $\operatorname{dp}[root][K]$ (так как если мы не корень, нужно еще 
       обрезать ребро в родителя).

      \subsubsection{Задача о разделении дерева}

\end{document}
