\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage{tikz}
\usetikzlibrary{arrows}


\definecolor{light-gray}{gray}{0.90}

\lstset{
	autogobble,
	breaklines = true,
    numbers = left,
    breaklines = true,
    tabsize = 1,
    backgroundcolor = \color{white},
    basicstyle = \ttfamily,
    keywordstyle = \bf\color{blue},
    language = Python,
	columns = flexible,
}

\pagestyle{empty}

\begin{document}
  \section{Динамическое программирование}

    \subsection{Общие принципы}

      \subsubsection{Построение, оптимизация, комбинаторика}

      Формулировки задач динамического программирования чаще всего
      требует найти один из трёх результатов:

      \begin{enumerate}
        \item Построить некоторый объект с набором свойств. Например,
          найти в дереве путь, проходящий ровно по двум вершинам
          из выделенных.
        \item Оптимизировать некоторый параметр. Например, найти
          наибольшую возрастающую подпоследовательность. Здесь
          подпоследовательность~--- это объект, а её длина оптимизируется.
        \item Подсчитать количество способов построить некоторый
          объект. Например, найти количество чисел из цифр $0$ и $1$,
          делящихся на $3$.
      \end{enumerate}

      \subsubsection{Подзадачи}

      Задачи, решаемые методом динамического программирования,
      имеют основную общую особенность. Задачу в них можно сформулировать
      так, что решение можно свести к решению аналогичных задач меньшего
      размера~--- \emph{подзадач}.

      (Оптимальность для подзадачи)
      
      \subsubsection{Состояния, переходы, база}

      \subsubsection{ДП как перебор с запоминанием}

      \subsubsection{Выделение параметров, избыточность}

      (Задача о трёх кучках монет)

      (Добавить параметр, чтобы преобразовать оптимизацию в построение)

      \subsubsection{Восстановление ответа}

    \subsection{ДП на префиксах}

      \subsubsection{Кратчайший путь в ациклическом графе}
      \textbf{Условие.} Дан ориентированный граф без циклов. Найти 
      длину кратчайшего пути от $s$ до $t$.
      
      Будем решать чуть более общую задачу ~--- искать длину кратчайших 
      путей от всех вершин до $t$ ($\operatorname{dist}[v]$ ~--- длина 
      кратчайшего пути от $v$ до $u$).
      
      Топологически отсортируем граф. Массив topsort - перестановка 
      вершин такая, что если если есть ребро $v\rightarrow u$ то $u$ 
      идет в topsort раньше, чем $v$. Найдем в этом массиве вершину $t$. 
      Из вершин, идущих в topsort раньше, t недостижима. Поэтому 
      для всех вершин $v$ идущих раньше $t \operatorname{dist}[v] = +\infty$, а 
      $\operatorname{dist}[t]$, очевидно, $0$.
      
      Будем считать $\operatorname{dist}[v]$ динамикой по префиксу 
      топологической сортировки:
      Предположим, что для всех вершин $u$, идущих в topsort-е раньше $v$ 
      $\operatorname{dist}[u]$ посчитано корректно. (База - $t$ и все 
      вершины идущие раньше нее) Рассмотрим какой-нибудь путь от $v$ до $t$. 
      Рассмотрим $w$ ~--- вторую вершину на этом пути. $w$ идет в topsort-е 
      раньше, чем $v$ (так как есть ребро $v\rightarrow w$), поэтому 
      $\operatorname{dist}[w]$ посчитано корректно. Если взять
      $\operatorname{dist}[v] = \min\limits_{w: \exists v \rightarrow w}
      (\operatorname{dist}[w] + \operatorname{weight}(v \rightarrow w))$, 
      то мы насчитаем правильный ответ для $v$, так как какая-то из ее соседей 
      должна быть второй на пути из $v$ в $t$ (если же пути из $v$ в $t$ нет, 
      то пути в $t$ нет ни из одного соседа $v$)
      
      Еще раз вкраце алгоритм: идем в порядке топологической сортировки графа
      и релаксируем ответ для текущей вершины по всем ребрам, из нее выходящим.
      \\
      
      Рассмотрим немного другое решение этой задачи, использующее так 
      называемую \emph{рекурсию с меморизацией}. 
      
      Примерный код:
      
      \begin{lstlisting}
          dist = [INF] * N
          counted = [False] * N
          dist[t] = 0
          counted[t] = True
          
          def dfs(v)
              if not counted[v]:
                  counted[v] = True
                  for (u, weight) in g[v]:
                      dist[v] = min(dist[v], dist[u] + weight)
              return dist[v]
      \end{lstlisting}
      
      Разберемся, что тут происходит.
      
      \textbf{Утверждение:} dfs($v$) возвращает корректное кратчайшее 
      расстояние от $v$ до $t$.
      
      Докажем его индукцией по времени выхода из вершины.
      
      База: если из вершины не выходит ни одного ребра, то это либо $t$, 
      и тогда dfs вернет $0$, что и требовалось, либо INF в противном случае,
      что тоже верно
      
      Переход: У всех соседей вершины $v$ время выхода не больше, чем у $v$
      (Свойство dfs на графе без циклов, то есть без обратных ребер). Поэтому, 
      применяя рассуждения предыдущего решения
      ($\operatorname{dist}[v] = \min\limits_{w: \exists v \rightarrow w}
      (\operatorname{dist}[w] + \operatorname{weight}(v \rightarrow w))$)
	  получаем корректность алгоритма.
	  
	  Алгоритм работает не более чем $\mathcal{O}(V + E)$, так как каждую вершину и
	  каждое ребро мы просмотрим не более одного раза (благодаря массиву counted)
	  
	  Если бы мы убрали массив counted, и поставили условие \lstinline{if v == t: return 0}
	  то код бы тоже работал, но, возможно, за очень долгое время (например, на 
	  бамбуке с раздвоенными ребрами он может работать $\mathcal{O}(2^V)$
	  \begin{center}
      	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
          thick,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
          	\node[main node] (1) {1};
          	\node[main node] (2) [right of=1]{2};
          	\node[main node] (3) [right of=2]{3};
          	\node[main node] (4) [right of=3]{4};
          	\node[main node] (5) [right of=4]{5};
          	
          	\path[] (1) [bend left] edge node [] {} (2);
          	\path[] (1) [bend right] edge node [] {} (2);
          	\path[] (2) [bend left] edge node [] {} (3);
          	\path[] (2) [bend right] edge node [] {} (3);
          	\path[] (3) [bend left] edge node [] {} (4);
          	\path[] (3) [bend right] edge node [] {} (4);
          	\path[] (4) [bend left] edge node [] {} (5);
          	\path[] (4) [bend right] edge node [] {} (5);
          	
        \end{tikzpicture}
        
        {\small Если $s = 1$ и $t = 5$ dfs вызовется $31$ раз}
      \end{center}
      
      Но мы пользуемся тем, что если мы один раз посчитали ответ для вершины, 
      его можно запомнить и в дальнейшем не пересчитывать. Такой прием и
      называется \emph{меморизацией}.
	  
	  При реализации алгоритма не забывайте, что $\infty + weight = \infty$
	  даже при отрицательных $weight$
      \subsubsection{НВП}

      \subsubsection{НОП}
    
    \subsection{ДП по цифрам числа}

      \subsubsection{Количество чисел от 0 до n с суммой цифр k}
    
    \subsection{ДП на подотрезках}

      \subsubsection{Оптимальное перемножение матриц}

      \subsubsection{Наибольшая подпоследовательность-палиндром, подматрица-палиндром}
      \subsubsection{Казино}

    \subsection{ДП на поддеревьях}

      \subsubsection{Взвешенное паросочетание в дереве}
      Ребро $e$ \emph{инцидентно} вершине $v$ и наоборот, вершина $v$ 
      \emph{инцидентна} ребру $e$, если $v$ является одним из концов $e$.
      \\
      
      \textbf{Условие.} Дано взвешенное дерево. Найти паросочетание (то есть 
      такой набор ребер, что каждой вершине инцидентно не более одного ребра из
      нашего набора) максимального суммарного веса.
      
      Подвесим дерево за какую-нибудь вершину. Будем считать динамику dp[$v$][0] 
      ~--- ответ для поддерева вершины $v$, если вершина $v$ не инцидентна ни 
      одному ребру из набора, и dp[$v$][1] ~--- ответ для поддерева вершины $v$
      без дополнительных ограничений.
      
      Примерный код:
      \begin{lstlisting}
      	dp = [[0, 0] for i in range(N)]
      	
      	def dfs(v):
      	    for (u, weight) in g[v]:
      	        dfs(u)
      	        dp[v][1] = max(dp[v][1] + dp[u][1], dp[v][0] + dp[u][0] + weight)
      	        dp[v][0] = dp[v][0] + dp[u][1]
      	    	
      \end{lstlisting}
	  
	  Подразумевается, что в g[$v$] хранится список смежности вершины
      $v$ без родителя.\\
      
      Разберемся, почему этот код работает:
      \textbf{Утверждение:} на $h$-м шаге внешнего цикла (4 строчка) 
      в dp[$v$][0] и dp[$v$][1] хранится ответ, для начала поддерева 
      вершины $v$ из нее самой и первых $h$ поддеревьев (нумерация с 1)
      \\
      
      Докажем его. При h = 0 утверждение очевидно. Пусть утверждение верно 
      после $h$ шагов, покажем, что оно верно и после $h + 1$ шага. Мы можем
      либо брать в наше паросочетание ребро в очередного ребенка $u$, либо не
      брать. Заметим, что оставшиеся ребра либо лежат в начале поддереве $v$ 
      (из нее и первых $h$ поддеревьев), либо в поддереве $u$.
      
      Разберем случай dp[$v$][1], то есть когда мы можем использовать 
      вершину $v$ в паросочетании:
      \begin{itemize}
          \item Пусть мы берем ребро $v \rightarrow u$. Рассмотрим оставшееся
          паросочетание. В нем ни $v$, ни $u$ не должны были быть использованы,
          а сумма ребер должна быть максимальной. Поэтому ответ для этого случая
          равен dp[$v$][0] + dp[$u$][0] + weight. 
      
          \item Если же мы не берем ребро $v \rightarrow u$, то мы свободны 
          брать и не брать как $u$, так и $v$. Этому случаю отвечает величина
          dp[$v$][1] + dp[$u$][1]
      \end{itemize}
      
      В случае dp[$v$][0], то есть когда мы не можем использовать вершину $v$
      брать ребро $v \rightarrow u$ уже нельзя. Остается набрать из начала 
      поддерева $v$ (из первых $h$ поддеревьев) и из поддерева $u$ ребер 
      по максимуму. Это и выражает формула dp[$v$][0] + dp[$u$][1]
      \\
      
      Время работы, очевидно, $\mathcal{O}(N)$

     
      \subsubsection{Выделение поддерева размера k}
      
      \textbf{Условие.} Дано дерево на $N$ вершинах и число $K$. 
      Найдите минимальное количество ребер, которое надо удалить из дерева, 
      чтобы одна из компонент оказалась размера ровно $K$. $\mathcal{O}(N^2)$
      
      Подвесим дерево за какую-нибудь вершину. Будем считать динамику 
      dp[$v$][$k$] ~--- минимальное количество ребер, при удалении которого
      поддерево $v$ распадется на такие компоненты, что содержащая $v$
      будет состоять из $k$ вершин.
      
      Примерный код:
      \begin{lstlisting}
          dp = [[INF] * (N + 1) for i in range(N)]
          size = [0] * N
          def dfs(v):
              size[v] = 1;
              dp[v][1] = len(g[v])
    
              for u in g[v]:
                  dfs(u)
                  for i in range(1, len(size[v]) + 1):
                      for j in range(1, len(size[u]) + 1):
                          dp[v][i + j] = min(dp[v][i + j], dp[u][j] + dp[v][i] - 1) 
                      size[v] += size[u]       
      \end{lstlisting}
      
      Подразумевается, что в g[$v$] хранится список смежности вершины
      $v$ без родителя.\\

      Разберемся почему этот код работает.

      \textbf{Утверждение:} на $h$-м шаге внешнего цикла (7 строчка) 
      в dp[$v$][$k$] хранится ответ, если в компоненту с вершиной $v$
      разрешается брать лишь вершины из первых $h$ поддеревьев (нумерация с 1)
      \\
      
      Докажем его. При h = 0 утверждение очевидно. Пусть утверждение верно 
      после $h$ шагов, покажем, что оно верно и после $h + 1$ шага. В нашу 
      компоненту мы можем либо брать вершины из $h$-го поддерева, либо нет. 
      Если мы не берем, то, по предположению индрукции ответ dp[$v$][$k$]. 
      Если же мы берем, то посмотрим, сколько вершин мы взяли из предыдущих 
      поддеревьев (за это отвечает переменная $i$), а сколько - из 
      $(h + 1)$-го поддерева (за это отвечает $j$). ну и платим мы за это 
      соответственно dp[$u$][$j$] + dp[$v$][$i$] - 1 (-1 так как раньше мы 
      удаляли ребро между $v$ и ее $(h + 1)$-м ребенком, а теперь нет). 
      Поскольку $i$ и $j$ пробегают все возможные значения, то ответ 
      посчитается корректно. 
      \\
      
      \textbf{Утверждение:} dfs($v$) работает за 
      $\mathcal{O}(\operatorname{size}[v]^2)$ 

      Докажем по индукции по размеру поддерева. Пусть $\omega_h$ - 
      размер поддерева $h$-го ребенка $v$. Обозначим за $z$ количество 
      детей $v$ В цикле (7) мы вызовем dfs от всех детей (это 
      будет $\sum(c \cdot \omega_h^2)$ по предположению индукции. 
      Возьмем $c > 2$). На $h$-м шаге size[$v$] = 
       $(1 + \omega_1 + \cdots + \omega_{h - 1})$ соответственно на 
       $h$-м шаге цикл (9) выполнит суммарно 
       $\omega_{h + 1}~\cdot~(\sum\limits_{j \leqslant h}(\omega_h)~+~1)$ 
       операций. $$\sum\limits_{h = 0}^{z - 1}(\omega_{h + 1} \cdot 
       (\sum\limits_{j \leqslant h}(\omega_h) + 1)) = \sum\limits_{1 \leqslant i 
       \leqslant j \leqslant z}(w_i \cdot w_j) + \sum_{i \leqslant z}w_i $$
       $$\sum_{i \leqslant z} (c w_i^2) \sum\limits_{1 \leqslant i < j 
       \leqslant z}(w_i \cdot w_j) + \sum_{i \leqslant z}w_i \buildrel 
       c > 2 \over \leqslant c \cdot (\sum\limits_{i \leqslant z} 
       w_i) ^ 2$$

       Что и требовалось доказать.
       
       Таким образом, dfs($root$) работает за $\mathcal{O}(N^2)$. 
       Как же найти ответ на исходную задачу? Так как какая-то вершина в 
       полученной компоненту будет иметь минимальную глубину, то достаточно 
       запустить dfs($root$) и потом выбрать минимум из 
       $\operatorname{dp}[v][K] + 1$ по всем $v$ кроме $root$ и 
       $\operatorname{dp}[root][K]$ (так как если мы не корень, нужно еще 
       обрезать ребро в родителя).

      \subsubsection{Задача о разделении дерева}

\end{document}
