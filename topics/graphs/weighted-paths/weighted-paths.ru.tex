\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{graphicx}
\usepackage{color}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{needspace}
\usepackage{listings}
\usepackage{tikz}
\tikzstyle{vertex}=[circle,draw=black,thick,fill=white,minimum size=17pt,inner sep=0pt]

\renewcommand{\le}{\leqslant}

\pagestyle{fancy}
\lhead{Взвешенные графы: поиск кратчайших путей}
\rhead{ЛКШ.2015.Июль.B}

\usepackage{amsmath, amssymb}
\DeclareMathOperator{\dist}{dist}
\DeclareMathOperator{\prev}{prev}
\DeclareMathOperator{\nextuv}{next}

\begin{document}
  \section{Кратчайшие пути}

  \emph{Длина пути}~--- сумма пометок, написанных на рёбрах графа (весов).

    \subsection{Графы без циклов отрицательного веса}
    Вершины на пути с наименьшей длиной не могут повторяться:
    иначе на пути есть цикл неотрицательного веса, который можно исключить из пути,
    уменьшив его длину.

    Значит, если есть путь из одной вершины в другую, то есть вершинно-простой путь
    наименьшей длины.

    \subsection{Графы с циклами отрицательного веса}
    Если из вершины $u$ есть путь в некоторый цикл отрицательного веса,
    и при этом есть некоторый путь из вершины на этом цикле в вершину~$v$,
    то не существует кратчайшего пути из вершины $u$ в $v$.

    Так как по отрицательному циклу можно пройти сколь угодно большое число раз,
    предъявив путь меньше любого наперёд заданного числа.

    Если такая ситуцация невозможна, то существует вершинно-простой путь из $u$ в $v$.

  \section{Алгоритм Форда-Беллмана}

    \subsection{Постановка задачи}
    Алгоритм решает задачу \emph{SSSP~--- Single Source Shortest Paths},
    то есть находит кратчайшие пути от выделенной вершины $s$ до всех остальных.
    Если кратчайшего пути в некоторую вершину $v$ нет, то алгоритм определяет,
    какая ситуация произошла: путь существует, но на нём есть отрицательный цикл,
    или же пути из $s$ в $v$ не существует.

    \subsection{Релаксация ребра}
    $\dist[v]$~--- длина самого короткого пути из $s$ в $v$,
    на данный момент найденная алгоритмом.

    Рассмотрим ребро $u \to v$, имеющее вес $w$.
    Если $\dist[v] > \dist[u] + w$, то найденное расстояние $u \leadsto v$,
    равное $\dist[v]$, можно улучшить на путь $s \leadsto u \to v$,
    проходящий через вершину $u$.
    
    Чтобы восстановить найденный путь $s \leadsto v$, необходимо запомнить
    предпоследнюю вершину на пути: $\prev[v] = u$.

    \begin{minipage}{0.5\linewidth}
    \lstinputlisting[language=Python]{edge-relax.py}
    \end{minipage}
    \begin{minipage}{0.4\linewidth}
    \begin{tikzpicture}[shorten >=1pt,->]
%      \tikzstyle{vertex}=[circle,fill=black!25,minimum size=17pt,inner sep=0pt]
      \draw plot [smooth] coordinates {(0,0) (1,0.1) (2,-0.1) (3,0.1) (4,-0.1) (5,0)};
      \node[vertex] (v-s) at (0,0) {$s$};
      \node[vertex] (v-u) at (4,-1) {$u$};
      \node[vertex] (v-v) at (5,0) {$v$};
      \draw (v-u) -- (v-v);
      \draw (v-s) .. controls +(-30:2cm) and +(-150:1cm) .. (v-u);
    \end{tikzpicture}
    \end{minipage}

    \subsection{Основной алгоритм}
      \subsubsection{Поиск кратчайших расстояний}
      Алгоритм Форда-Беллмана $(V - 1)$ раз релаксирует
      все ребра в произвольном порядке.
      \lstinputlisting[language=Python]{ford-bellman.py}
      
      При дальнейших релаксациях рёбер, расстояние до вершин,
      до которых существует кратчайшее расстояние, обновляться не будет.

      Очевидно, что асимптотическое время работы есть $O(VE)$.
    
      \subsubsection{Поиск множества вершин, достижимых из циклов отрицательного веса}
      После выполнения ещё одной релаксации всех рёбер
      на каждом отрицательном цикле обновится расстояние хотя бы до одной вершины.
    
      Пометим их и из каждой запустим dfs. До всех вершин,
      которые пометил dfs, кратчайшего расстояния не существует.
      \lstinputlisting[language=Python]{mark-bad-vertices.py}
      
      \subsubsection{Недостижимые из $s$ вершины}
      Вершина $v$ не достижима из $s$, тогда и только тогда,
      когда после работы алгоритма $\dist[v] = +\infty$.
      
    \subsection{Тонкости реализации}
    \begin{enumerate}
    \item Проверка в релаксации ребра \texttt{dist[v] > dist[u] + w} может сработать,
          если \texttt{dist[u] == +INF}, при условии, что $w < 0$.
          Расстояние до $v$ обновится, и мы будем считать, что есть путь в $v$.
          
          Поэтому релаксировать ребро в графе с отрицательными рёбрами
          следует при условии: \texttt{dist[u] < +INF \&\& dist[v] > dist[u] + w}.
    \item Величины в массиве \texttt{dist} могут стать меньше \texttt{-INF}
          и переполнится. Это приведёт к некорректной работе алгоритма.
          
          Поэтому стоит проверять новое значение $\dist[v]$ после релаксации и
          устанавливать в \texttt{-INF}, если нужно.
    \item С учётом замечаний, релаксация ребра должна происходить так:
         \lstinputlisting[language=Python]{edge-relax-correct.py}
    \end{enumerate}

    \subsection{Доказательство корректности}
    Если существует кратчайший вершинно-простой путь, то на нём не более $V$ вершин,
    а значит, не более $(V - 1)$ ребра.
    
    \emph{Инвариант алгоритма}~--- после $k$ релаксаций всех рёбер графа,
    $\dist[v]$ будет равно длине кратчайшего пути, на котором не более $k$ рёбер.
    
    Докажем это по индукции:

    \noindent\begin{minipage}{\textwidth}
    \begin{enumerate}
      \item Очевидно, что это верно до первого шага: все вершины, кроме $s$,
      не достижимы по нулю рёбер.    

      После первого шага, мы обновим только расстояние до смежных с $s$ вершин,
      таким образом найдя кратчайшие расстояния из 1 ребра.
    
      \item Кратчайшие пути из не более $(k - 1)$ ребра к началу $k$-ой итерации
            мы уже нашли.
      \item Любой путь из $k$ рёбер, это путь из $(k - 1)$ ребра и ещё одно ребро.
            Поскольку для каждой вершины мы релаксируем все входящие в неё рёбра,
            то после $k$-ой итерации, найдём кратчайшие пути из не более $k$ рёбер.
    \end{enumerate}
    \end{minipage}

  \section{Алгоритм Флойда-Уоршелла}

    \subsection{Постановка задачи}
    Алгоритм решает задачу \emph{APSP~--- All Pairs Shortest Paths},\\
    то есть находит кратчайшие пути между всеми парами вершин.
    Если кратчайшего пути между $u$ и $v$ нет, то алгоритм определяет,
    какая ситуация произошла: путь существует, но на нём есть отрицательный цикл,
    или же пути из $u$ в $v$ не существует.

    \subsection{Основной алгоритм}
      \subsubsection{Поиск кратчайших расстояний}
      Находим кратчайшие расстояния с помощью динамического программирования.
      Кратчайшие пути вершинно-простые: каждая вершина используется не более
      одного раза.
      
      $\dist_k[u][v]$~--- длина кратчайшего пути из вершины $u$
      в вершину $v$ по вершинам с номерами строго меньше $k$.
      Таким образом, состояние динамики~--- матрица $n \times n$.
      
      Заметим, что матрица $\dist_0$~--- это матрица путей, не использующих
      промежуточные вершины, то есть просто матрица смежности.
      
      База есть, осталось научиться переходить от матрицы $\dist_k$ к $\dist_{k+1}$.
      Пути $\dist_k$ использовали вершины с номерами $0, 1, \dots (k-1)$.
      В матрице $\dist_{k+1}$ разрешено использовать вершину с номером $k$.
      
      Длина кратчайшего пути из $u$ в $v$, использующего вершину $k$, равна
      $\dist_k[u][k] + \dist_k[k][v]$, если не использовать, то $\dist_k[u][v]$.
      Таким образом: \[
        \dist_{k+1}[u][v] =
        \min\left(\dist_k[u][v],\ \dist_k[u][k] + \dist_k[k][v]\right)
      \]

      \noindent\begin{minipage}{\textwidth}
      \begin{tikzpicture}[shorten >=1pt,->]
        \draw plot [smooth] coordinates {
          (0, 0) (1, 0.1) (2, -0.1) (3, 0.1) (4, -0.1) (5, 0.1) (6, 0)
        };

        \node[vertex] (u) at (0,0) {$u$};
        \node[vertex] (v) at (6,0) {$v$};
        \node[vertex] (k) at (4,-1) {$k$};
        \draw (u) to[out=-40,in=190] (k);
        \draw (k) to[out=10,in=220] (v);
      \end{tikzpicture}
      \lstinputlisting[language=Python]{floyd.py}
      \end{minipage}

      Заметим, что можно хранить все величины в одной матрице $\dist$, экономя память.
      Так как в момент обновления $\dist[u][v] \le \dist_k[u][v]$
      (пути покороче нам нравятся ещё больше).

      \subsubsection{Восстановление ответа}
      На каждом пути $u \leadsto v$ давайте хранить не только его величину, но и
      предпоследнюю вершину.

      Изначально, при инициализации алгоритма, для каждого ребра ${u \to v}$ положим
      $\prev[u][v] = u$, для остальных -1.
      
      Предпоследняя вершина на пути $u \leadsto k \leadsto v$ такая же,
      как и на пути $k \leadsto v$. Поэтому, если
      при обновлении расстояния $\dist[u][v]$ можно пересчитать
      $\prev[u][v] = \prev[k][v]$.
      
      Имея предыдущую вершину на пути, легко восстановить и сам путь:
      \lstinputlisting[language=Python]{floyd-get-path.py}
      
      Чтобы путь не переворачивать, можно хранить не $\prev[u][v]$, а $\nextuv[u][v]$.
      
      \subsubsection{Тонкости реализации}
      Если есть отрицательные рёбра, то необходимо делать проверку:\\
      \texttt{dist[u][k] != +INF and dist[k][v] != +INF}
      (смотри замечания к алг. Форда-Беллмана).
   
      А также стоит следить за тем, чтобы \texttt{dist[u][v] >= -INF}.

      \subsubsection{Графы с отрицательными рёбрами}
      Если есть отрицательные циклы и нет кратчайшего пути,
      то алгоритм находит длину какого-то пути, если он есть.
      
      В этом случае вершины могут использоваться несколько раз
      (т.к. пути необязательно вершинно-простые), значит,
      восстановление пути не будет работать для таких путей.
      
      На главной диагонали будут стоять длины не тривиальных циклов
      $\dist[v][v]$~--- длина пути из $v \leadsto v$. Неотрицательное число
      соответствует длине кратчайшего цикла, содержащего $v$,
      отрицательное~--- длине какого-то цикла отрицательной длины.
      
      Из $u$ в $v$ нет кратчайшего пути тогда и только тогда, когда есть путь
      $u \leadsto k \leadsto v$, где $k$ лежит на отрицательном цикле.
      Помечаем все такие пути:
      \lstinputlisting[language=Python]{floyd-mark-bad.py}
      
      Если на таком пути пойти по массиву \texttt{prev}, восстанавливая путь,
      то мы зациклимся на цикле отрицательного веса. Так можно найти какой-то
      цикл отрицательного веса, если начать с вершины $v$,
      такой что ${\dist[v][v] < 0}$.

  \section{Алгоритм Дейкстры}
  Очевидно! =)
\end{document}
