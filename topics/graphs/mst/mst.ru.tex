\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amsfonts}
\usepackage{verbatim}

\pagestyle{plain}
\hoffset = -11mm
\voffset = -20mm
\textwidth = 155mm
\textheight = 235mm
\usepackage{indentfirst}

\renewcommand{\le}{\leqslant}                                                    
\renewcommand{\ge}{\geqslant}

\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}

\begin{document}

\section{Остовные деревья}

\subsection{Определение}

\emph{Остовным деревом (spanning tree)} связного неориентированного графа $G$ на $n$ вершинах будем называть подмножество его ребер размера $n-1$, не содержащее циклов. 
Понятно, что тогда по этим ребрам можно добраться из любой вершины до любой, и эти ребра образуют дерево. Если граф $G$ взвешенный, суммарный 
вес ребер остовного дерева будем называть \emph{весом} остовного дерева. Классическая задача ~--- построить остовное дерево минимального веса \emph{(minimal spanning tree, или MST)}.

\subsection{Важное утверждение}

\textbf{Утверждение.} Пусть $F$~--- некоторое множество ребер, которое можно достроить (т.е. добавить сколько-то ребер) до MST. Пусть $S$~--- некоторая компонента связности по ребрам $F$ и $e$~--- любое из минимальных ребер, ведущих из множества $S$ наружу (т.е. в вершину, не лежащую в $S$). Тогда множество $F' = F + e$ тоже можно достроить до некоторого MST.

\begin{proof}

Рассмотрим $T$~--- MST, cодержащее в себе $F$. Если оно содержит также и $e$, то все хорошо. Иначе добавим к $T$ ребро $e$, от этого в нем появился ровно один простой цикл. Пойдем вдоль этого цикла, начиная с ребра $e$. На первом шаге мы выйдем из множества $S$ наружу, но должны когда-то туда вернуться. Пусть $f$~--- первое ребро, по которому мы возвращаемся в $S$. $w(f) \geq w(e)$, поскольку $e$~--- минимальное из ребер, ведущих из $S$ наружу. Удалим из графа $f$, получили множество $T'$; оно является деревом, поскольку мы удалили ребро на единственном цикле. Кроме этого, $w(T') = w(T) - w(f) + w(e) \leq w(T)$, и $T$~--- MST, значит, $T'$ тоже MST и содержит в себе множество $F + e$. Доказали.

\end{proof}

Применяя это утверждение на разные лады, будем получать разные алгоритмы для построения MST.

\section{Алгоритм Прима}

Общая схема алгоритма Прима такова: изначально в $F$ нет ребер. Выберем произвольную вершину $v$, ее компонента связности $S$ сначала состоит из нее самой. На каждом шаге мы имеем право добавить любое минимальное ребро, идущее из $S$ наружу, при этом другой конец ребра добавится в $S$; будем повторять этот процесс, пока $S$ не станет равно всему множеству вершин. В конечном итоге $F$ будет состоять из ребер MST.

Чтобы каждый раз не искать минимальное ребро заново, сделаем следующее: для каждой вершины $u$, не лежащей в $S$, будем поддерживать $dist[u]$~--- вес минимального ребра, ведущего из $S$ в $u$, либо $\infty$, если такого ребра нет; кроме этого, будем хранить $parent[u]$~--- вершина в $S$, которая является концом минимального ребра, ведущего в $u$ (если такое есть). Тогда на каждом шаге надо просто выбрать вершину $u$, не лежащую в $S$, с минимальным $dist[u]$, добавить $u$ в $S$ и ребро из $u$ в $parent[u]$ в множество $F$. После добавления вершины $u$ в множество $S$, у нас могли поменяться $dist[v]$ для остальных вершин, т.к. ребра, исходящие из $u$, там еще не учтены. Пройдем по всем таким ребрам и поменяем $dist[v]$ для тех вершин, где новые ребра являются минимальными.

На каждом шаге множество $S$ расширяется на одну вершину, значит, после $n-1$ шага алгоритм завершится. На каждом шаге мы должны выбрать вершину с минимальным $dist[u]$. Можно делать это, например, простым проходом по массиву $dist$, что потребует $O(n)$ операций на каждом шаге, и $O(n^2)$ операций суммарно. Кроме этого, требуется рассмотреть все ребра для пересчитывания $dist[v]$, но легко заметить, что каждое ребро будет рассмотрено не более двух раз (в каждую из сторон). Таким образом, суммарное время работы такой реализации алгоритма Прима составляет $O(n^2 + m) = O(n^2)$ (как обычно, $n$ и $m$ ~--- количество вершин и ребер в графе соответственно)

Узкое место здесь ~--- это поиск следующей вершины для добавления в $S$. Воспользуемся для этой цели какой-либо структурой данных, которая поддерживает операции добавления элемента и извлечения минимума за время $O(\log n)$, где $n$~--- количество элементов в структуре; в качестве такой структуры можно взять, например, кучу или \texttt{std::set}. Теперь операция выбора новой вершины требует $O(\log n)$ операций в худшем случае, но каждое изменение $dist[v]$ требует изменения элемента в куче, поэтому суммарное время работы стало равно $O(n \log n + m \log n) = O(m \log n)$. Мы видим, что в случае неплотных графов (т.е. $m$ гораздо меньше $n^2$) реализация алгоритма Примы с кучей позволяет существенно выиграть по времени, но в случае плотных графов ($m$ порядка $n^2$) реализация с кучей проигрывает простой реализации ($O(n^2 \log n)$ против $O(n^2)$).

\end{document}
