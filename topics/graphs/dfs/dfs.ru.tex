\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}

\usepackage{fullpage}
\usepackage{graphicx}

\pagestyle{empty}

\begin{document}
  \section{Поиск в глубину}

    \subsection{Понятия и алгоритм}

      \subsubsection{Поиск (обход) графа}

      \emph{Обход графа} --- перечисление его вершин и рёбер
      в некотором порядке, и алгоритм, который это перечисление
      строит.

      \subsubsection{Основной алгоритм}

      \emph{Поиск (обход) в глубину} определяется следующим
      алгоритмом:
      \begin{enumerate}
        \item Рассмотреть необработанную вершину $v$
        \item Запомнить, что $v$ обработана
        \item Найти все рёбра $e: v \to u$, исходящие из $v$,
          и запустить обход в глубину из этой вершины
      \end{enumerate}

      Несложно заметить, что обработанными будут все вершины,
      до которых есть путь из вершины, откуда был запущен обход.

      Чаще всего указанный алгоритм запускают последовательно
      для всех необработанных вершин графа, таким образом строится
      обход всего графа вне зависимости от его связности.

      \subsubsection{Метки посещения}

      Для каждой вершины алгоритм требует помнить, обработана ли она.
      Чаще всего это можно запомнить в булевом массиве: для
      вершины $v$ будет храниться логическое значение $visited[v]$,
      равное $false$ исходно. Как мы увидим дальше, для каждой вершины
      полезно будет хранить более подробные отметки.

      \subsubsection{Дерево обхода}

      Заметим, что в каждую вершины алгоритм зайдёт не больше одного
      раза, потому что как только это произойдёт, вершина будет помечена
      как посещённая. Это значит, что все посещённые вершины образуют
      дерево с корнем в той вершине, из которой обход был начат.

      Чтобы построить дерево явным образом, можно запоминать для
      каждой вершины её родителя в момент, когда производится рекурсивный
      вызов.

      \subsubsection{Классификация рёбер}

      В процессе обхода в глубину рёбра можно классифицировать.

      \begin{enumerate}
        \item \emph{Рёбра дерева} --- это рёбра, соединяющие каждую вершину
          с её родителем в дереве обхода. Иными словами, это те рёбра,
          по которым алгоритм проходил в новые, ещё не посещённые вершины.
        \item \emph{Обратные рёбра} --- это рёбра, ведущие из вершины в её
          предков в дереве обхода.
        \item \emph{Прямые рёбра} --- это рёбра, ведущие из вершины в
          её потомков в дереве обхода.
        \item \emph{Перекрёстные рёбра} --- это рёбра, не попавшие
          ни в один из предыдущих классов.
      \end{enumerate}

      \begin{itemize}
        \item Если граф является ориентированным, можно заметить,
          что каждое обратное ребро соответствует простому циклу.

        \item Если граф является неориентированным, то можно заметить
          несколько вещей:
          \begin{enumerate}
            \item Во-первых, перекрёстных рёбер нет (докажите).
            \item Каждое прямое ребро $u \to v$ является также обратным
              $v \to u$
            \item Каждое обратное ребро $u \to v$ является также
              прямым $v \to u$, либо ребром дерева $v \to u$.
          \end{enumerate}
      \end{itemize}

      \subsubsection{Время входа и выхода}

      В алгоритм можно добавить отметки <<времени>>: моменты, когда
      рекурсивная функция начинала обрабатывать вершину, и когда
      заканчивала это делать. Обычно для этого можно использовать
      последовательные целые числа.
      Обозначим за $t^{in}_v$ время входа, а за
      $t^{out}_v$ время выхода из вершины.

      Заметим, что эти времена образуют правильную скобочную
      последовательность:
      \begin{itemize}
        \item $t^{in}_v < t^{in}_u < t^{out}_u < t^{out}_v$, если вершина
          $v$ является предком вершины $u$,
        \item $t^{in}_u < t^{in}_v < t^{out}_v < t^{out}_u$, если вершина
          $v$ является потомком вершины $u$,
        \item $t^{in}_v < t^{out}_v < t^{in}_u < t^{out}_u$ или
          $t^{in}_u < t^{out}_u < t^{in}_v < t^{out}_v$ иначе.
      \end{itemize}

      \subsubsection{Метки трёх цветов}

      В процессе работы алгоритма можно использовать не только разделение
      на обработанные и необработанные вершины, но и более сложную
      структуру. Часто это называют раскраской вершин в чёрный, серый и
      белый цвета.

      Исходно все вершины помечаются белым: они не начали обработку.
      В момент входа в вершину она помечается серым: обработка начата.
      В момент выхода из вершины она помечается чёрным: обработка
      закончена.

      Это хороший способ обнаружить обратные рёбра: они и только они
      ведут из серой вершины в серую. Рёбра дерева при этом ведут из
      серой в белую, а остальные --- из серой в чёрную.

      \subsubsection{* Особенности реализации для дерева}

      Если обход в глубину запускается на дереве (чаще всего, из корня),
      единственными рёбрами, не входящими в дерево обхода, будут обратные
      к ним. Разумеется, это верно только для неориентированных деревьев.
      В частности, это позволяет не хранить массив пометок. Зацикливания
      можно избежать, запретив переход из вершины в её родителя.

    \subsection{Применения}

      \subsubsection{Проверка на предка}

      Запустив на дереве обход в глубину и вычислив времена входа и выхода,
      достаточно проверить, вкладываются ли эти пары друг в друга.

      \subsubsection{Компоненты связности}

      Для неориентированного графа обход в глубину помечает все вершины,
      лежащие в одной компоненте связности с данной, и только их.
      
      \subsubsection{Поиск циклов}

      Любое обратное ребро соответствует циклу. Для неориентированных
      графов, обратные рёбра, совпадающие с рёбрами дерева, являются
      единственным исключением.
      
      \subsubsection{Топологическая сортировка}

      Если в графе нет циклов, можно расположить вершины в порядке,
      обратном времени выхода. Этот порядок и будет топологической
      сортировкой: все рёбра будут вести <<вперёд>>.

      \subsubsection{Раскраска графа в два цвета}

      Вершина должна быть раскрашена в цвет, противоположный цвету
      её предка в дереве обхода. Все рёбра, кроме рёбер дерева,
      достаточно проверить на соответствие.

      \subsubsection{Компоненты сильной связности}

      Запустим поиск в глубину и запомним времена выхода из вершин.
      Инвертируем все рёбра и запустим поиск в глубину ещё раз
      в порядке убывания запомненного времени выхода $t^{out}_v$.
      Каждый очередной запуск поиска в глубину из ещё не помеченной
      вершины будет проходить очередную компоненту сильной связности.

      Идеи доказательства:
      \begin{itemize}
        \item Пусть вершина $u$ помечена при очередном запуске поиска
          по инвертированному графу из вершины $v$.
          Значит, из неё в исходном графе достижима $v$.
        \item Известно, что $t^{out}_v > t^{out}_u$.
          Предположим, что $u$ не лежит в одной компоненте сильной
          связности с $v$. Тогда из $v$ не достижима $u$. Значит,
          $t^{in}_v > t^{out}_u$. Но это означает, что из $u$
          недостижима $v$, что неверно.
      \end{itemize}

      Каждую компоненту сильной связности можно <<сжать>> в одну
      вершину. Получится граф, который называется
      \emph{конденсацией} исходного графа.
      
      Докажите:
      \begin{itemize}
        \item Конденсация ациклична
        \item Описанный алгоритм перечисляет вершины конденсации
          в порядке топологической сортировки
      \end{itemize}

      \subsubsection{Мосты}

      Вычислим следующую функцию: для всех вершин в поддереве $v$
      минимальное время входа в вершину, достижимое по одному
      обратному ребру из вершин этого поддерева. Обозначим эту
      функцию как $l_v$.

      \begin{enumerate}
        \item Если ребро не является ребром дерева, оно не является
          мостом. Очевидно: ведь тогда его можно удалить, и связность
          по дереву не изменится.
        \item Ребро дерева $p \to v$ является мостом тогда и только
          тогда, когда $l_v > t^{in}_p$. Предположим, что неравенство
          выполняется и удалим данное ребро. Заметим, что путь из
          любой вершины данного поддерева наружу невозможен: все
          обратные рёбра будут вести ниже. Импликация в обратную
          сторону очевидна.
      \end{enumerate}

      \subsubsection{Точки сочленения}

      Аналогичным образом вычислим функцию $l_v$.

      Посмотрим, потеряется ли связность при удалении вершины. Для этого
      поддерево одного из её детей не должно иметь возможности выйти
      <<выше>>.

      Таким образом, вершина $v$ с отцом $p$ будет точкой сочленения
      в том и только том случае, если среди её детей есть вершина
      $u: l_u > t^{in}_p$ (докажите).

      Ситуация с корнем несколько отличается: его удаление не приведёт
      к пропаданию связности с предками. Корень является точкой сочленения
      в том и только том случае, если у него хотя бы два ребёнка в дереве
      обхода (докажите).

      \subsubsection{Компоненты двусвязности}

      Для компонент как вершинной, так и рёберной двусвязности, можно
      применить схожие алгоритмы. Во-первых, нужно находить, соответственно,
      точки сочленения или мосты. Во-вторых, в процессе обхода нужно
      добавлять текущие рёбра или вершины в стек, а в момент обнаружения
      компоненты снимать все её элементы со стека.

      \subsubsection{* Эйлеров цикл}

      \subsubsection{* Максимальное паросочетание в двудольном графе}

      \subsubsection{* Наименьший общий предок}

\end{document}
