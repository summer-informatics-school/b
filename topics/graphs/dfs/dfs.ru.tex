\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}

\usepackage{fullpage}
\usepackage{graphicx}

\pagestyle{empty}

\begin{document}
  \section{Поиск в глубину}

    \subsection{Понятия и алгоритм}

      \subsubsection{Поиск (обход) графа}

      \emph{Обход графа} --- перечисление его вершин и рёбер
      в некотором порядке, и алгоритм, который это перечисление
      строит.

      \subsubsection{Основной алгоритм}

      \emph{Поиск (обход) в глубину} определяется следующим
      алгоритмом:
      \begin{enumerate}
        \item Рассмотреть необработанную вершину $v$
        \item Запомнить, что $v$ обработана
        \item Найти все рёбра $e: v \to u$, исходящие из $v$,
          и запустить обход в глубину из этой вершины
      \end{enumerate}

      Несложно заметить, что обработанными будут все вершины,
      до которых есть путь из вершины, откуда был запущен обход.

      Чаще всего указанный алгоритм запускают последовательно
      для всех необработанных вершин графа, таким образом строится
      обход всего графа вне зависимости от его связности.

      \subsubsection{Метки посещения}

      Для каждой вершины алгоритм требует помнить, обработана ли она.
      Чаще всего это можно запомнить в булевом массиве: для
      вершины $v$ будет храниться логическое значение $visited[v]$,
      равное $false$ исходно. Как мы увидим дальше, для каждой вершины
      полезно будет хранить более подробные отметки.

      \subsubsection{Дерево обхода}

      Заметим, что в каждую вершины алгоритм зайдёт не больше одного
      раза, потому что как только это произойдёт, вершина будет помечена
      как посещённая. Это значит, что все посещённые вершины образуют
      дерево с корнем в той вершине, из которой обход был начат.

      Чтобы построить дерево явным образом, можно запоминать для
      каждой вершины её родителя в момент, когда производится рекурсивный
      вызов.

      \subsubsection{Классификация рёбер}

      В процессе обхода в глубину рёбра можно классифицировать.

      \begin{enumerate}
        \item \emph{Рёбра дерева} --- это рёбра, соединяющие каждую вершину
          с её родителем в дереве обхода. Иными словами, это те рёбра,
          по которым алгоритм проходил в новые, ещё не посещённые вершины.
        \item \emph{Обратные рёбра} --- это рёбра, ведущие из вершины в её
          предков в дереве обхода.
        \item \emph{Прямые рёбра} --- это рёбра, ведущие из вершины в
          её потомков в дереве обхода.
        \item \emph{Перекрёстные рёбра} --- это рёбра, не попавшие
          ни в один из предыдущих классов.
      \end{enumerate}

      \begin{itemize}
        \item Если граф является ориентированным, можно заметить,
          что каждое обратное ребро соответствует простому циклу.

        \item Если граф является неориентированным, то можно заметить
          несколько вещей:
          \begin{enumerate}
            \item Во-первых, перекрёстных рёбер нет (докажите).
            \item Каждое прямое ребро $u \to v$ является также обратным
              $v \to u$
            \item Каждое обратное ребро $u \to v$ является также
              прямым $v \to u$, либо ребром дерева $v \to u$.
          \end{enumerate}
      \end{itemize}

      \subsubsection{Время входа и выхода}

      В алгоритм можно добавить отметки <<времени>>: моменты, когда
      рекурсивная функция начинала обрабатывать вершину, и когда
      заканчивала это делать. Обычно для этого можно использовать
      последовательные целые числа.
      Обозначим за $t^{in}_v$ время входа, а за
      $t^{out}_v$ время выхода из вершины.

      Заметим, что эти времена образуют правильную скобочную
      последовательность:
      \begin{itemize}
        \item $t^{in}_v < t^{in}_u < t^{out}_u < t^{out}_v$, если вершина
          $v$ является предком вершины $u$,
        \item $t^{in}_u < t^{in}_v < t^{out}_v < t^{out}_u$, если вершина
          $v$ является потомком вершины $u$,
        \item $t^{in}_v < t^{out}_v < t^{in}_u < t^{out}_u$ или
          $t^{in}_u < t^{out}_u < t^{in}_v < t^{out}_v$ иначе.
      \end{itemize}

      \subsubsection{Метки трёх цветов}

      В процессе работы алгоритма можно использовать не только разделение
      на обработанные и необработанные вершины, но и более сложную
      структуру. Часто это называют раскраской вершин в чёрный, серый и
      белый цвета.

      Исходно все вершины помечаются белым: они не начали обработку.
      В момент входа в вершину она помечается серым: обработка начата.
      В момент выхода из вершины она помечается чёрным: обработка
      закончена.

      Это хороший способ обнаружить обратные рёбра: они и только они
      ведут из серой вершины в серую. Рёбра дерева при этом ведут из
      серой в белую, а остальные --- из серой в чёрную.

      \subsubsection{* Особенности реализации для дерева}

      Если обход в глубину запускается на дереве (чаще всего, из корня),
      единственными рёбрами, не входящими в дерево обхода, будут обратные
      к ним. Разумеется, это верно только для неориентированных деревьев.
      В частности, это позволяет не хранить массив пометок. Зацикливания
      можно избежать, запретив переход из вершины в её родителя.

    \subsection{Применения}

      \subsubsection{Проверка на предка}

      \subsubsection{Компоненты связности}
      
      \subsubsection{Поиск циклов}
      
      \subsubsection{Топологическая сортировка}

      \subsubsection{Раскраска графа в два цвета}

      \subsubsection{Компоненты сильной связности}

      \subsubsection{Мосты}

      \subsubsection{Точки сочленения}

      \subsubsection{Компоненты двусвязности}

      \subsubsection{* Эйлеров цикл}

      \subsubsection{* Максимальное паросочетание в двудольном графе}

      \subsubsection{* Наименьший общий предок}

\end{document}
